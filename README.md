<p align="center">
<h1 align="center">Brick Oven</h1>
<h3 align="center">Easily create & format brick templates with the brick_oven cli generator for mason</h3>
</p>

<p align="center">
<a href="https://pub.dev/packages/brick_oven"><img src="https://img.shields.io/pub/v/brick_oven.svg" ></a>
<a href="https://github.com/mrgnhnt96/brick_oven"><img src="https://img.shields.io/github/stars/mrgnhnt96/brick_oven.svg?style=flat&logo=github&colorB=yellow&label=stars" ></a>
<a href="https://pub.dev/packages/very_good_analysis"><img src="https://img.shields.io/badge/style-very_good_analysis-B22C89.svg" ></a>
<a href="https://github.com/tenhobi/effective_dart"><img src="https://img.shields.io/badge/style-effective_dart-40c4ff.svg" ></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/license-MIT-blue.svg" ></a>
</p>

Brick Oven is essentially a "Search & Replace" tool on steroids. It is for cooking (generating) and formatting brick templates for [mason].

# Quick Start

```bash
# üéØ Activate from https://pub.dev
dart pub global activate brick_oven

# üî® Create & configure the `brick_oven.yaml` file

# üéõ cook your bricks üß±
brick_oven cook all
```

# Cook'n Bricks! üë®‚Äçüç≥

Cook up a brick template for each configured brick within the `brick_oven.yaml` file.

There are two main commands to cook your bricks:

```bash
# Cooks all bricks
brick_oven cook all

# Cooks a specific brick
brick_oven cook <BRICK_NAME>
```

# Setup the oven üéõ

Use the JSON Schema to help with intellisense and validation

The link to the schema is `https://raw.githubusercontent.com/mrgnhnt96/brick_oven/master/schema/brick_oven.yaml.schema.json`

If you're using vscode, you can update your project's settings.json to include the schema

```json
{
  "yaml.schemas": {
    "https://raw.githubusercontent.com/mrgnhnt96/brick_oven/master/schema/brick_oven.yaml.schema.json": "brick_oven.yaml"
  }
}
```

To see some examples of the `brick_oven.yaml` usage, check out the [test/e2e/sources](https://github.com/mrgnhnt96/brick_oven/blob/master/test/e2e/sources) folders

**_Note for formats and subdirectory variables_**: When a variable is used as a directory name _and_ it is formatted, the directory slash will be replaced with the format's delimiter.

```console
-- generated by brick_oven --
{{#snakeCase}}{{{path}}}{{/snakeCase}}

-- set the variable `path` to `some/path/to/dir` --

-- Result, generated by mason --
some_path_to_dir
```

# Content Configuration

This is where brick_oven really shines! Because it is a "Search & Replace" tool, you're able to format the "placeholders" within the contents of a file however you'd like.

**Note for output directory**: The default output directory is `bricks`, this value can be manipulated with the `output` argument. The generated content will be placed under `BRICK_NAME/__brick__/`, this value cannot be changed.

**_Note for variable names_**: Because brick_oven is a "Search & Replace" tool, it will replace ALL found occurrences. The var `name` is found in `rename, name, something_name`. To avoid this, its recommended to set up your placeholders with a prefix and/or suffix (such as "`_`") and some sort of case formatting (such as CONSTANT_CASE). Example: `_NAME_`.

**_Note for variable ordering_**: The order of replacing placeholders with their mustache syntax formatted values is: `sections`, `vars`, followed by `partials`. To avoid unintentionally replacing a placeholder with a sub-name (e.g. `NAME` found in `NAMES` or  `_NAME_` found in `_MY_NAME_`), try using multiple placeholders for the same variable, and ordering the variables in the brick_oven.yaml by length (largest to smallest).

## Partials

Partials are a way to reuse a template. brick_oven supports partials nested within folders, however, mason does not [yet](https://github.com/felangel/mason/issues/378). brick_oven handles this by re-locating the partials to the root of the project. This means that all partials _**must have a unique file name.**_

| Syntax | Example | Output |
| --- | --- | --- |
| partials.* | partials.hello_world | {{> hello_world.dart}} |

Accessing partials is by using dot annotation. For example, if you have a partial named `hello_world.dart`, you can access it by using `partials.hello_world` (extension is optional)

## URLs

URLs are empty text files _with no file extension_

## Sections (Lambdas)

| Syntax | Example | Output | Description |
| --- | --- | --- | --- |
| section* | section_FOO_ | {{#\_FOO_}} | The start of a section |
| endSection* | endSection_FOO_ | {{/\_FOO_}} | The end of a section |
| invertSection* | invertSection_FOO_ | {{^\_FOO_}} | The start of an **inverted** section |

**Notes**:

- Sections consume the **entire** line (start to end, only 1 line). This is helpful if you want to comment out a section based on the language's syntax, or add a helpful description after/before the section
- Sections do not get [formatted](#case-formatting). So don't try to format them...
- Sections are **_not_** case sensitive

### Built in Variables

There are some keywords to help get the value at the index when iterating over a list

- **\_INDEX_VALUE_**
- **.** (a single period)

Both have the same output of\
`{{#_FOO_}}{{.}}{{/_FOO_}}`

## Conditional Sections

| Syntax | Example | Output | Description |
| --- | --- | --- | --- |
| *if | _FOO_if | {{#\_FOO_}} | Start of an if statement |
| *ifNot | _FOO_ifNot | {{^\_FOO_}} | Inverts the if statement |
| *endIf | _FOO_endIf | {{/\_FOO_}} | End of the if statement |

**Note**: Conditional sections **_not_** case sensitive

## Case Formatting

[Available formats](https://github.com/mrgnhnt96/brick_oven/blob/master/lib/enums/mustache_tag.dart), Case formatting syntax is **_not_** case sensitive

| Syntax | Example | Output |
| --- | --- | --- |
| *snake, \*snakecase| _FOO_snake, _FOO_snakecase | {{#snakeCase}}{{\_FOO_}}{{/snakeCase}} |
****

**Note:** You can NOT format a variable _and_ use it as a section/if statement.
